# cvpletter.py
#
# Converts raw CVBasic DATA sections into Pletter-compressed chunks.
#
# Copyright (c) 2025 Troy Schrapel
#
# This code is licensed under the MIT license
#
# https://github.com/visrealm/retropipe
#

import re
import sys
import os
import subprocess
from pathlib import Path
from tempfile import TemporaryDirectory

# Determine pletter executable path
# Priority: environment variable > command-line arg > default bundled exe
PLETTER_EXE = None
if 'PLETTER_EXE' in os.environ:
    PLETTER_EXE = Path(os.environ['PLETTER_EXE'])
else:
    scriptDir = Path(__file__).parent.resolve()
    PLETTER_EXE = scriptDir / 'cvbasic' / 'pletter.exe'

def extractLabelsAndData(basPath):
    """Parses a .bas file and extracts labeled DATA BYTE sequences."""
    currentLabel = None
    labelDataMap = {}
    dataBuffer = []

    with open(basPath, 'r') as f:
        for line in f:
            stripped = line.strip()

            if not stripped or stripped.startswith("'"):
                continue  # skip empty and comment lines

            # detect label declarations (e.g., LabelName:)
            codeOnly = stripped.split("'", 1)[0].strip()
            if re.match(r'^[a-zA-Z_][\w]*\s*:$', codeOnly):

                if currentLabel and dataBuffer:
                    labelDataMap[currentLabel] = dataBuffer
                currentLabel = codeOnly[:-1]
                dataBuffer = []
                continue

            # remove comments and extract DATA BYTE declarations
            match = re.search(r'DATA\s+BYTE\s+(.*)', codeOnly, re.IGNORECASE)
            if match and currentLabel:
                byteValues = match.group(1).split(',')
                for byte in byteValues:
                    byte = byte.strip()
                    if byte.startswith('"') and byte.endswith('"'):
                        # Handle string: strip quotes and convert each char to its ASCII value
                        for char in byte[1:-1]:
                            dataBuffer.append(ord(char))
                    elif byte.startswith('$'):
                        dataBuffer.append(int(byte[1:], 16))
                    elif byte.lower().startswith('0x'):
                        dataBuffer.append(int(byte, 16))
                    else:
                        dataBuffer.append(int(byte))
    if currentLabel and dataBuffer:
        labelDataMap[currentLabel] = dataBuffer

    return labelDataMap

def compressDataViaPletter(data, tempDir, label):
    """writes data to disk, compresses it via pletter.exe, and reads back output bytes."""
    binPath = tempDir / f"{label}.bin"
    pletterPath = tempDir / f"{label}.pletter.bin"

    with open(binPath, 'wb') as f:
        f.write(bytearray(data))

    result = subprocess.run([str(PLETTER_EXE), str(binPath), str(pletterPath)],
                            capture_output=True, text=True)

    if result.returncode != 0:
        raise RuntimeError(f"[âœ—] Pletter compression failed for {label}:\n{result.stderr}")

    with open(pletterPath, 'rb') as f:
        return list(f.read())

def writeFinalBas(inputBas, basOutputPath, compressedBlocks, sourceSizes):
    """generates the output .pletter.bas with compressed data blocks."""

    totalSourceBytes = 0
    totalCompressedBytes = 0
    basOutputFile = Path(basOutputPath).name

    with open(basOutputPath, 'w') as f:
        f.write("' ====================================================\n")
        f.write("' This file was generated using cvpletter.py\n")
        f.write("' \n")
        f.write("' Copyright (c) 2025 Troy Schrapel (visrealm)\n")
        f.write("' \n")
        f.write(f"' source: {inputBas}\n")
        f.write(f"' cmd:    python cvpletter.py {inputBas}\n")
        f.write(f"' output: {basOutputFile}\n")
        f.write("' \n")
        f.write("' ====================================================\n")
        f.write("' WARNING! Do NOT edit this file. Edit source file\n")
        f.write("' ====================================================\n\n")

        for label, compressed in compressedBlocks.items():
            inSize = sourceSizes[label]
            outSize = len(compressed)
            totalSourceBytes += inSize
            totalCompressedBytes += outSize

            f.write(f"  {label}Pletter: ' source: {inSize} bytes. compressed: {outSize} bytes\n")
            for i in range(0, outSize, 8):
                group = compressed[i:i+8]
                line = ', '.join(f"${b:02x}" for b in group)
                f.write(f"    DATA BYTE {line}\n")
            f.write("\n")

            print(f"  {label + 'Pletter:':<25} - in: {str(inSize) + 'B':>6} - out: {str(outSize) + 'B':>6} - saved: {str(inSize - outSize)+'B':>6}")

    print(f"{basOutputFile:<27} - in: {str(totalSourceBytes) + 'B':>6} - out: {str(totalCompressedBytes) + 'B':>6} - saved: {str(totalSourceBytes - totalCompressedBytes)+ 'B':>6}\n")

def main():
    if len(sys.argv) != 2:
        print("Usage: python cvpletter.py <input.bas>")
        sys.exit(1)

    inputBas = Path(sys.argv[1])
    if not inputBas.exists():
        print(f"[X] File not found: {inputBas}")
        sys.exit(1)

    if not PLETTER_EXE.exists():
        print(f"[X] Missing pletter.exe at: {PLETTER_EXE}")
        sys.exit(1)

    print(f"Processing {inputBas}...")

    labelsData = extractLabelsAndData(inputBas)
    compressedBlocks = {}
    sourceSizes = {}

    with TemporaryDirectory() as tmp:
        tempDir = Path(tmp)
        for label, data in labelsData.items():
            compressedBlocks[label] = compressDataViaPletter(data, tempDir, label)
            sourceSizes[label] = len(data)

    outputBasPath = Path.cwd() / f"{inputBas.stem}.pletter.bas"
    writeFinalBas(inputBas, outputBasPath, compressedBlocks, sourceSizes)

if __name__ == '__main__':
    main()