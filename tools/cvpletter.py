# --------------------------------------------------
# Project: retropipe
# Purpose: Converts raw CVBasic DATA sections into Pletter-compressed chunks.
# Author:  Troy Schrapel
# License: MIT
# Repo:    https://github.com/visrealm/retropipe
# --------------------------------------------------

import re
import sys
import subprocess
from pathlib import Path
from tempfile import TemporaryDirectory

# Determine script directory and path to pletter.exe
SCRIPT_DIR = Path(__file__).parent.resolve()
PLETTER_EXE = SCRIPT_DIR / 'cvbasic' / 'pletter.exe'

def extract_labels_and_data(bas_path):
    """Parses a .bas file and extracts labeled DATA BYTE sequences."""
    label = None
    labels = {}
    data_accum = []

    with open(bas_path, 'r') as f:
        for line in f:
            stripped = line.strip()

            if not stripped or stripped.startswith("'"):
                continue  # Skip empty and comment lines

            # Detect label declarations (e.g., LabelName:)
            if re.match(r'^[a-zA-Z_][\w]*\s*:*$', stripped):
                if label and data_accum:
                    labels[label] = data_accum
                label = stripped[:-1]
                data_accum = []
                continue

            # Remove comments and extract DATA BYTE declarations
            code_only = stripped.split("'", 1)[0].strip()
            match = re.search(r'DATA\s+BYTE\s+(.*)', code_only, re.IGNORECASE)
            if match and label:
                bytes_str = match.group(1).split(',')
                for b in bytes_str:
                    b = b.strip()
                    if b.startswith('$'):
                        data_accum.append(int(b[1:], 16))
                    elif b.lower().startswith('0x'):
                        data_accum.append(int(b, 16))
                    else:
                        data_accum.append(int(b))

    if label and data_accum:
        labels[label] = data_accum

    return labels

def compress_data_via_pletter(data, tempdir, label):
    """Writes data to disk, compresses it via pletter.exe, and reads back output bytes."""
    bin_path = tempdir / f"{label}.bin"
    plet_path = tempdir / f"{label}.pletter.bin"

    with open(bin_path, 'wb') as f:
        f.write(bytearray(data))

    result = subprocess.run([str(PLETTER_EXE), str(bin_path), str(plet_path)],
                            capture_output=True, text=True)

    if result.returncode != 0:
        raise RuntimeError(f"[âœ—] Pletter compression failed for {label}:\n{result.stderr}")

    with open(plet_path, 'rb') as f:
        return list(f.read())

def write_final_bas(input_bas, bas_output, compressed_blocks, source_sizes):
    """Generates the output .pletter.bas with compressed data blocks."""
    
    source_bytes = 0
    compressed_bytes = 0
    
    with open(bas_output, 'w') as f:
        bas_output = Path(bas_output).name
        f.write("' ====================================================\n")
        f.write("' This file was generated using cvpletter.py\n")
        f.write("' \n")
        f.write("' Copyright (c) 2025 Troy Schrapel (visrealm)\n")
        f.write("' \n")
        f.write(f"' source: {input_bas}\n")
        f.write(f"' cmd:    python cvpletter.py {input_bas}\n")
        f.write(f"' output: {bas_output}\n")
        f.write("' \n")
        f.write("' ====================================================\n")
        f.write("' WARNING! Do NOT edit this file. Edit source file\n")
        f.write("' ====================================================\n\n")
        
        for label, compressed in compressed_blocks.items():
            source_bytes += source_sizes[label]
            compressed_bytes += len(compressed)
            f.write(f"  {label}Pletter: ' source: {source_sizes[label]} bytes. compressed: {len(compressed)} bytes\n")
            for i in range(0, len(compressed), 8):
                group = compressed[i:i+8]
                line = ', '.join(f"${b:02x}" for b in group)
                f.write(f"    DATA BYTE {line}\n")
            f.write("\n")
            print(f"  {label + "Pletter:":<25} - in: {str(source_sizes[label]) + "B":>6} - out: {str(len(compressed)) + "B":>6} - saved: {str(source_sizes[label] - len(compressed))+"B":>6}")


    print(f"{bas_output:<27} - in: {str(source_bytes) + "B":>6} - out: {str(compressed_bytes) + "B":>6} - saved: {str(source_bytes - compressed_bytes)+ "B":>6}\n")

def main():
    if len(sys.argv) != 2:
        print("Usage: python cvbasic_pletter_inline.py <input.bas>")
        sys.exit(1)

    input_bas = Path(sys.argv[1])
    if not input_bas.exists():
        print(f"[X] File not found: {input_bas}")
        sys.exit(1)

    if not PLETTER_EXE.exists():
        print(f"[X] Missing pletter.exe at: {PLETTER_EXE}")
        sys.exit(1)

    print(f"Processing {input_bas}...")

    labels_data = extract_labels_and_data(input_bas)
    compressed_blocks = {}
    source_sizes = {}

    with TemporaryDirectory() as tmp:
        tempdir = Path(tmp)
        for label, data in labels_data.items():
            compressed_blocks[label] = compress_data_via_pletter(data, tempdir, label)
            source_sizes[label] = len(data)

    output_bas = Path.cwd() / f"{input_bas.stem}.pletter.bas"
    write_final_bas(input_bas, output_bas, compressed_blocks, source_sizes)

if __name__ == '__main__':
    main()